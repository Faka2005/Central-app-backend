// prisma/schema.prisma
// Define your database models

generator client {
  provider = "prisma-client.js"
  //output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
url      = env("DATABASE_URL")
}


model User {
  id        String   @id @default(uuid())
  username  String
  email     String   @unique
  password  String
  role      String   @default("user")
  createdAt DateTime @default(now())

  // côté "inverse" de la relation one-to-one
  profil    Profil?  @relation("UserProfil")
    sentFriendRequests     Friend[] @relation("UserFriends")    // user qui envoie
  receivedFriendRequests Friend[] @relation("UserFriendOf")  // user qui reçoit
  passwords Password[] @relation("UserPasswords")
}

model Profil {
  id        String           @id @default(uuid())
  firstname String
  lastname  String
  bio       String?
  interests ProfilInterest[] // relation many-to-many
  niveau    String
  campus    String
  isTutor   Boolean          @default(false)

  // côté "définissant" la relation (clé étrangère)
  userId    String?          @unique
  user      User?            @relation("UserProfil", fields: [userId], references: [id])

  courses   TutorLesson[]    // Leçons proposées par ce profil (si tutor)
}

model TutorLesson {
  id        String    @id @default(uuid())
  title     String
  content   String
  niveau    String     // Niveau de la leçon
  tutorId   String
  tutor     Profil     @relation(fields: [tutorId], references: [id])
  createdAt DateTime   @default(now())
}

model Interest {
  id       String            @id @default(uuid())
  name     String            @unique
  profils  ProfilInterest[]
}

model ProfilInterest {
  profilId   String
  interestId String
  profil     Profil   @relation(fields: [profilId], references: [id])
  interest   Interest @relation(fields: [interestId], references: [id])

  @@id([profilId, interestId])
}

model Friend {
  id        String   @id @default(uuid())
  userId    String
  friendId  String
  status    String   @default("pending") // "pending", "accepted", "blocked"
  createdAt DateTime @default(now())

  user      User     @relation("UserFriends", fields: [userId], references: [id])
  friend    User     @relation("UserFriendOf", fields: [friendId], references: [id])

  @@unique([userId, friendId]) // éviter les doublons
}

model Reciter {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  basePath  String   // ex: /files/Yasser_Al_Dossary
  createdAt DateTime @default(now())


}


model Service {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String
  link        String
  etat        Boolean  @default(false) // false = en développement, true = actif
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


model Password {
  id          String   @id @default(uuid())

  description String
  site        String
  email       String
  password    String

  createdAt   DateTime @default(now())


  userId      String
  user        User     @relation("UserPasswords", fields: [userId], references: [id])
}
