// prisma/schema.prisma
// Define your database models

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}


model User {
  id        String   @id @default(uuid())
  username  String
  email     String   @unique
  password  String
  role      String   @default("user")
  createdAt DateTime @default(now())

  // c√¥t√© "inverse" de la relation one-to-one
  profil    Profil?  @relation("UserProfil")
    sentFriendRequests     Friend[] @relation("UserFriends")    // user qui envoie
  receivedFriendRequests Friend[] @relation("UserFriendOf")  // user qui re√ßoit
  //passwords Password[] @relation("UserPasswords")
}

model Profil {
  id        String           @id @default(uuid())
  firstname String
  lastname  String
  bio       String?
  interests ProfilInterest[] // relation many-to-many
  niveau    String
  campus    String
  isTutor   Boolean          @default(false)

  // c√¥t√© "d√©finissant" la relation (cl√© √©trang√®re)
  userId    String?          @unique
  user      User?            @relation("UserProfil", fields: [userId], references: [id])

  courses   TutorLesson[]    // Le√ßons propos√©es par ce profil (si tutor)
}

model TutorLesson {
  id        String    @id @default(uuid())
  title     String
  content   String
  niveau    String     // Niveau de la le√ßon
  tutorId   String
  tutor     Profil     @relation(fields: [tutorId], references: [id])
  createdAt DateTime   @default(now())
}

model Interest {
  id       String            @id @default(uuid())
  name     String            @unique
  profils  ProfilInterest[]
}

model ProfilInterest {
  profilId   String
  interestId String
  profil     Profil   @relation(fields: [profilId], references: [id])
  interest   Interest @relation(fields: [interestId], references: [id])

  @@id([profilId, interestId])
}

model Friend {
  id        String   @id @default(uuid())
  userId    String
  friendId  String
  status    String   @default("pending") // "pending", "accepted", "blocked"
  createdAt DateTime @default(now())

  user      User     @relation("UserFriends", fields: [userId], references: [id])
  friend    User     @relation("UserFriendOf", fields: [friendId], references: [id])

  @@unique([userId, friendId]) // √©viter les doublons
}

//////////////////////////////////////////////////
// üéôÔ∏è RECITER (R√©citateur)
//////////////////////////////////////////////////
model Reciter {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  basePath  String   // ex: /files/Yasser_Al_Dossary
  createdAt DateTime @default(now())

  surahs    Surah[]
}

//////////////////////////////////////////////////
// üìñ SURAH (Sourate)
//////////////////////////////////////////////////
model Surah {
  id         String   @id @default(uuid())
  number     Int      // 1 ‚Üí 114
  name       String
  audioFile  String   // ex: 001.mp3
  createdAt  DateTime @default(now())

  reciterId  String
  reciter    Reciter  @relation(fields: [reciterId], references: [id])

  @@unique([number, reciterId]) // 1 sourate unique par r√©citateur
}
model Service {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String
  link        String
  etat        Boolean  @default(false) // false = en d√©veloppement, true = actif
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


//model Password {
//  id          String   @id @default(uuid())
//  title       String
//  description String
//  site        String
//  email       String
//  password    String
//
//  createdAt   DateTime @default(now())
//  updatedAt   DateTime @updatedAt
//
//  userId      String
//  user        User     @relation("UserPasswords", fields: [userId], references: [id])
//}
